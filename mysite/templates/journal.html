<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Journal | Learning Journal</title>
    <link rel="manifest" href="{{ url_for('static', filename='manifest.json') }}">
    <meta name="theme-color" content="#0069d9">

    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>
<body>
    <div id="offline-indicator">⚠️ You are currently offline. Content may be outdated.</div>

    <header id="nav-placeholder">
        <button id="theme-toggle">Toggle Dark Mode</button>
    </header>

    <main>
        <h1>Weekly Learning Journal</h1>
        <p>This is where I document my weekly learning progress and answer the required unit questions.</p>

        <section class="card" id="journal-storage-feature">
            <h2>Write a Journal Entry</h2>
            <p>Type your quick reflection below and click 'Save'. The text will be saved to your browser's Local Storage (Storage API) and simultaneously sent to the Flask server.</p>

            <form id="entry-form">
                <label for="new-entry-text" style="display: block; margin-bottom: 5px;">Your Quick Entry:</label>
                <textarea id="new-entry-text" style="width: 100%; min-height: 150px; padding: 10px; border: 1px solid #ccc; border-radius: 4px; margin-bottom: 15px;"></textarea>

                <button type="submit" id="notify-button" class="cta-button">Save Entry & Notify</button>
            </form>

            <div id="saved-entry-display" style="margin-top: 30px; padding: 10px; border: 1px dashed var(--primary-color);">
                </div>
        </section>

        <section class="card">
            <h2>Python JSON Reflections (Live from Flask Backend)</h2>

            <div class="action-bar">
                <button id="export-json" class="action-btn export-btn">Export JSON</button>
                <button id="delete-last-json" class="action-btn btn-secondary">Delete Last Entry (Extra Feature)</button>
                <div class="counter">Entries: <span id="reflection-count">0</span></div>
            </div>

            <div id="json-reflections" class="reflections-list"></div>
        </section>

                <article>
            <h2>Mini Project: Focus Timer</h2>

            <h3>1. What additional features did you add to your Learning Journal?</h3>
            <p>For my mini-project, I developed a "Focus Timer" (Pomodoro Clock) directly integrated into the PWA. This feature serves as a personal productivity tool designed to help users manage their study sessions effectively. The timer allows users to select from preset durations—specifically a standard 25-minute focus session, a short 5-minute break, or a longer 15-minute break. Key functionalities include a live digital countdown, state controls (Start, Pause, Reset), and browser notifications that alert the user when their session is complete.</p>

            <h3>2. Why did you choose your mini project idea?</h3>
            <p>I chose the Focus Timer because it aligns perfectly with the core purpose of the application: a "Learning Journal." While the existing features allowed users to record what they learned, the app lacked a tool to facilitate the actual process of learning. By adding a Pomodoro timer, the application transitions from a passive recording log to an active study companion. From a technical perspective, I selected this idea to demonstrate mastery of JavaScript Time Intervals and asynchronous state management, moving beyond simple CRUD operations to solve a real-time problem.</p>

            <h3>3. What technical challenges did you face and how did you solve them?</h3>
            <p>The most significant technical challenge was state persistence across navigation. Initially, the timer would reset to the default 25:00 whenever I navigated to the Journal page to write an entry. To solve this, I implemented a strategy using the Local Storage API where I saved the target "end timestamp" rather than just the seconds remaining. This allowed the timer to recalculate the correct remaining time immediately upon reloading the page. I also faced a CSS conflict where my transparent buttons were invisible against the white background; I resolved this by using specific CSS overrides to enforce the primary text color.</p>

            <h3>4. What would you improve if given more time?</h3>
            <p>If I had more time, I would implement automatic journal integration. Currently, the timer simply alerts the user when finished; an improved version would automatically create a "Draft Entry" in the Journal section stating that a session was completed. Additionally, I would enhance the offline reliability of the notifications by moving the countdown logic into a Service Worker or Web Worker. This would ensure that the timer continues to run and alerts the user even if the browser tab is minimized or closed.</p>
        </article>


        <article>
            <h2>Week 7: PWA & Offline Implementation</h2>

            <h3>1. Why is it useful to enhance your Flask app with PWA features?</h3>
            <p>Enhancing the Flask app with PWA features is useful because it transforms a standard website into a reliable, installable application. By using a Web App Manifest, users can install the journal to their home screen like a native app. Service Workers allow the app to load instantly and function even without an internet connection, ensuring that the user's experience is not interrupted by poor network conditions.</p>

            <h3>2. What did you use to support offline access and dynamic data?</h3>
            <p>To support offline access, I utilized a <strong>Service Worker</strong> (<code>sw.js</code>). During the <code>install</code> phase, I cached critical static assets (HTML, CSS, JS, and images) using the Cache Storage API. For data handling, I used the Service Worker's <code>fetch</code> event listener to intercept network requests; if the network fails, the Service Worker retrieves the requested resources directly from the local cache.</p>

            <h3>3. What extra feature did you add, and why?</h3>
            <p>I implemented an <strong>Offline Detection Banner</strong> as my extra feature. Using the <code>navigator.onLine</code> property and window event listeners (<code>online</code>/<code>offline</code>), a red warning banner appears automatically when the internet connection drops. I added this to improve User Experience (UX) by giving the user immediate visual feedback that they are viewing cached content and cannot save new entries.</p>

            <h3>4. Did you face any challenges deploying your PWA, and how did you solve them?</h3>
            <p>The main challenge was the <strong>Service Worker Scope</strong>. Since my <code>sw.js</code> file was physically located in the <code>static/js/</code> folder, it couldn't control the HTML pages in the root directory by default. I solved this by configuring a specific route in Flask (<code>@app.route('/sw.js')</code>) to serve the file from the root URL, essentially "tricking" the browser into accepting the correct scope while keeping my file structure organized.</p>
        </article>

        <article>
            <h2>Week 6: Flask Backend Integration</h2>

            <h3>1. Why is the frontend-backend connection important?</h3>
            <p>The connection is important because it allows our simple PWA to become a real application that handles persistent data. The frontend (HTML, CSS, JS) handles what the user sees and clicks, while the backend (Flask) handles the data storage, security, and complex logic. Without a backend, reflections would be lost when you close the browser.</p>

            <h3>2. Which HTTP methods did you use in Flask, and why?</h3>
            <p>I used the `GET` method to retrieve (or "read") all the stored reflections, and the `POST` method to submit (or "create") a new reflection from the form. I chose these because they are the standard methods defined by REST principles for handling data. For my extra feature, I also used `DELETE` to remove an entry.</p>

            <h3>3. What is the difference between using Flask to store and load JSON data and reading JSON directly in the browser?</h3>
            <p>If we read JSON directly in the browser, the data is static (it can't change), and we can't save new entries. Using Flask means the JSON data is stored on the server (PythonAnywhere), which makes it persistent, meaning it saves across all sessions and devices. The browser's Local Storage is temporary and only works on one device, but Flask provides a central, permanent record.</p>

            <h3>4. Did you face any difficulties when running your project on PythonAnywhere? How did you handle them?</h3>
            <p>Yes, the main challenge was ensuring the Flask script had the correct file paths and permissions to read and write to the `reflections.json` file. I handled this by carefully checking the Flask configuration and using the PythonAnywhere error logs to pinpoint where the script was failing. I also had to remember to Reload the web app after every code change for the updates to take effect.</p>

            <h3>5. What extra feature did you build into your PWA with Flask, and why did you add it?</h3>
            <p>I added Delete functionality, allowing a user to remove the most recent reflection using the `DELETE` HTTP method. This was important because a real application needs to allow users to manage their data, not just add to it. It demonstrates that the PWA has full  (Create, Read, Update, Delete) capabilities.</p>
        </article>


        <article>
            <h2>Week 5: Python & JSON Backend Data</h2>
            <h3>1. How is storing data in a JSON file different from using browser storage?</h3>
            <p>JSON file storage persists on the server/file system and can be easily shared, backed up, or processed by other applications. Browser storage (like localStorage) is client-side only and limited to the specific browser/device. JSON files are better for permanent records that need to be accessed by multiple systems, while browser storage is ideal for temporary session data and user preferences.</p>

            <h3>2. How did you use Python to create or update your JSON file?</h3>
            <p>I created a Python script (<code>save_entry.py</code>) that takes user input via the command line, adds a timestamp, and appends the reflection to a JSON array. The script uses <code>json.load()</code> to read existing data and <code>json.dump()</code> to write the updated array back to the file with proper formatting. This creates a simple backend system for managing reflection data.</p>

            <h3>3. What does your PWA show locally, and what will users see on GitHub? Are they the same? Why or why not?</h3>
            <p>Locally, the PWA shows actual reflections loaded from the JSON file (after running the Python script). On GitHub Pages, users will see demo reflections from the pre-populated JSON file, but they cannot add new entries via Python. They're different because GitHub Pages serves static files only and cannot execute Python scripts or maintain file changes between visits.</p>

            <h3>4. What extra feature did you add to your PWA using the JSON file, and why?</h3>
            <p>I added an Export button that allows users to download their reflections as a JSON file for backup or sharing. This feature enhances data portability and gives users control over their content. The export functionality demonstrates practical file handling and provides a valuable utility for users who want to save their progress externally.</p>
        </article>

        <article>
            <h2>Week 4: Introduction to APIs</h2>

            <h3>1. Which Storage, Browser, and Third-Party APIs did you choose, and why?</h3>
            <ul>
                <li>Storage API: I chose Local Storage to persist the theme preference and save the latest journal entry. I chose it for its simplicity and directness in storing small amounts of data across browser sessions.</li>
                <li>Browser API: I chose the Notifications API to provide direct user feedback (confirming a successful entry save). This enhances the PWA feel by moving confirmation away from simple pop-ups.</li>
                <li>Third-Party API: I chose the Advice Slip API to fetch a piece of daily wisdom for the homepage. I chose this because it is free, keyless, and demonstrates external data fetching using the Fetch API without requiring complex authentication.</li>
            </ul>

            <h3>2. How did you integrate each API with DOM manipulation?</h3>
            <ul>
                <li>Local Storage: Integrated with the DOM by reading the `themePreference` on page load to set the `<body>` class, and by reading/writing the content in the `#saved-entry-display` div.</li>
                <li>Notifications API: Integrated via a user event (submit on the form), where the successful saving triggers a notification that uses the PWA's icon for better branding.</li>
                <li>Third-Party API: Integrated by using the `fetch` results to dynamically populate the `innerHTML` of the `#quote-container` element on the homepage.</li>
            </ul>

            <h3>3. What challenges did you encounter, and how did you solve them?</h3>
            <p>The main challenges were debugging the fetch API security blocks and handling the modular JavaScript file dependencies. The fetch API failed when testing locally due to CORS issues; this was solved by committing and pushing the code to GitHub Pages for testing over a secure HTTPS connection. The dependency issue was solved by strictly ensuring that files defining functions (e.g., `storage.js`) were linked in the HTML before the files that called those functions (e.g., `browser.js`).</p>

            <h3>4. In what ways do these APIs improve your Learning Journal PWA?</h3>
            <p>The APIs significantly improve the PWA by providing persistence (theme/entry storage), user engagement (notifications), and dynamic content (daily wisdom/advice). The PWA now feels less like a static webpage and more like a proper application that remembers the user and provides current, relevant content.</p>
        </article>

        <article>
            <h2>Week 3: JavaScript & DOM Manipulation</h2>

            <h3>1. Which DOM selection methods did you use, and why did you choose them?</h3>
            <p>I primarily used document.getElementById() to select elements. I chose this method because the elements I needed to target (like the nav-placeholder and live-date) have unique IDs, making it the most direct and fastest selection method available.</p>

            <h3>2. What was the most challenging part about linking JavaScript with your HTML?</h3>
            <p>The most challenging part was ensuring the JavaScript file was linked correctly and loaded at the appropriate time. Since the JavaScript is performing DOM manipulation (like inserting the navigation), it must be placed just before the closing </body> tag so the HTML elements (the placeholders) are already defined and available for selection when the script executes.</p>

            <h3>3. How did you test and debug your JavaScript code?</h3>
            <p>I tested and debugged the JavaScript code by running the HTML pages in the browser and utilizing the Browser Developer Tools (Console tab). The Console was critical for checking two things: verifying that the navigation was inserted correctly (structure check) and watching for runtime errors when executing the Date() object and DOM methods like .innerHTML and .textContent.</p>
        </article>

        <article>
            <h2>Week 2: Frontend Fundamentals</h2>

            <h3>1. How did you approach mobile-first design?</h3>
            <p>I approached mobile-first design by following the principle of progressive enhancement. I started by setting up a minimal layout and styling optimized for the narrowest screen width (mobile phones) without using any media queries. I then used a single media query (`@media (min-width: 768px)`) to apply specific styles for larger devices, such as switching the navigation to a horizontal row and centering the main content. This ensures a fast loading time for mobile users.</p>

            <h3>2. What was the most useful HTML or CSS concept you applied this week?</h3>
            <p>The most useful CSS concept I applied this week was Flexbox. I used Flexbox heavily to handle the responsive layout requirements, specifically on the `<body>` element to ensure the footer stays fixed at the bottom, and to manage the dynamic shift of the navigation bar from a vertical stack on mobile to a horizontal row on desktop within the media query.</p>

            <h3>3. What part of HTML or CSS did you find most challenging or confusing?</h3>
            <p>The most challenging part of CSS was fully grasping the correct implementation of the mobile-first mindset. It was initially confusing to intentionally design a basic, small layout first and then design for the desktop. Understanding where to place the universal styles (outside the media query) and where to place the complex, desktop-specific styles (inside the media query) was the key hurdle.</p>
        </article>

        <article>
            <h2>Week 1: Introduction (Temperature Converter PWA)</h2>

            <h3>Reflection on Steps Followed</h3>
            <p>This lab focused on getting familiar with tools and platforms for multi-platform development, centered around building a Temperature Converter PWA.</p>

            <ul>
                <li>GitHub & VS Code: I created the repository and used the GitHub Repositories extension in VS Code to sign in and easily manage commits and pushes directly from the editor.</li>
                <li>PWA Fundamentals: I implemented core PWA components, including setting up the manifest file and service worker to make the app installable and work offline.</li>
                <li>Deployment: The project was deployed publicly using GitHub Pages and also hosted on PythonAnywhere. This helped me understand the difference between static hosting (GitHub Pages) and platforms that support server-side code.</li>
                <li>Mobile Platforms: I downloaded and ran the provided Kotlin code in Android Studio to understand native application structure. I managed to run the sample app in my mobile phone, which was faster than the emulator.</li>
            </ul>

            <h3>Challenges Faced</h3>
            <p>The main challenge was ensuring all the file paths were correct for the PWA components and handling external assets.</p>
            <ul>
                <li>External Asset Issue: I encountered an issue with the image path for the PWA icon, which required me to manually webs scrape the image and use a direct HTTPS URL inside `manifest.json` for the icon source.</li>
                <li>Server Configuration: I had to configure the WSGI file on PythonAnywhere to correctly handle the content types (HTML, CSS, JS, etc.) for the static files to run properly.</li>
            </ul>
        </article>
    </main>

    <footer>
        <p>&copy; 2025 Soman Tamang. All rights reserved.</p>
    </footer>

    <script src="{{ url_for('static', filename='js/storage.js') }}"></script>
    <script src="{{ url_for('static', filename='js/script.js') }}"></script>
    <script src="{{ url_for('static', filename='js/browser.js') }}"></script>
    <script src="{{ url_for('static', filename='js/thirdparty.js') }}"></script>
    <script src="{{ url_for('static', filename='js/jsonhandler.js') }}"></script>

</body>
</html>
